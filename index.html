<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta http-equiv="Cache-Control" content="no-store"/>
<title>Русские шашки</title>
<link rel="stylesheet" href="./styles.css?v=1">
<script src="https://telegram.org/js/telegram-web-app.js"></script>
<script src="./src/tg-viewport.js"></script>
</head>
<body>
<div id="app" class="app-root">
  <header class="header">
    <div class="title">Русские шашки</div>
    <button id="btn-settings" class="btn-ghost">Настройки</button>
    <button id="btn-back" class="btn-ghost" hidden>Назад</button>
  </header>

  <main class="content">
    <section id="view-game" class="view">
      <div class="game">
        <div class="board-wrap"><div class="board"><canvas id="board" width="1024" height="1024"></canvas></div></div>
        <aside class="side-panel">
          <div class="meta">
            <div>Ход: <b id="turnLabel">—</b></div>
            <div>Статус: <b id="statusLabel">—</b></div>
          </div>
        </aside>
      </div>
    </section>

    <section id="view-settings" class="view" hidden>
      <form class="settings-form">
        <fieldset>
          <legend>Игра</legend>
          <label>Режим
            <select id="mode" class="select">
              <option value="ai">1 игрок (с ИИ)</option>
              <option value="pvp">2 игрока</option>
            </select>
          </label>
          <label>Уровень ИИ
            <select id="level" class="select">
              <option value="0">0 (быстрый)</option>
              <option value="1" selected>1 (средний)</option>
              <option value="2">2 (сложный)</option>
            </select>
          </label>
          <label><input id="mustCapture" type="checkbox" checked> Бить обязательно</label>
          <label>Цвет игрока
            <select id="yourColor" class="select">
              <option value="white" selected>Белые (начинают)</option>
              <option value="black">Чёрные</option>
            </select>
          </label>
        </fieldset>
        <fieldset>
          <legend>Оформление</legend>
          <label>Тема
            <select id="themeSelect" name="theme">
              <option value="classic">Classic</option>
              <option value="walnut">Walnut</option>
              <option value="graphite">Graphite</option>
            </select>
          </label>
          <label><input id="sfxOn" type="checkbox" name="sfx" checked> Звуки ходов</label>
          <label><input id="musicOn" type="checkbox" name="music"> Музыка</label>
        </fieldset>
        <button type="button" id="btn-newgame" class="btn-primary">Новая игра</button>
      </form>
    </section>
  </main>

  <footer class="footer">
    <div class="controls">
      <button id="btnUndo" data-action="undo" class="btn">Отменить</button>
      <button id="btnHint" data-action="hint" class="btn">Подсказка</button>
      <button id="btnRestart" data-action="new"  class="btn btn-primary">Сдаться / Новая</button>
    </div>
  </footer>
</div>

<script src="./src/gestures-guard.js"></script>
<script type="module" src="./index.js"></script>
<script type="module">
  import { initAudio, playMove as playMoveSfx } from './src/audio.js?v=2';
  import { showEndModal } from './src/modal.js?v=1';
  import { getLegalMoves } from './src/moves.js?v=1';
  window.AudioAPI = { initAudio, playMove: playMoveSfx, showEndModal, getLegalMoves };
  window.addEventListener('pointerdown', () => {
    if (!window.__audioStarted) {
      window.__audioStarted = true;
      initAudio();
    }
  }, { once:true });
</script>
<script type="module">
  import { showGame, showSettings } from './src/nav.js';

  const SIZE=8, DARK=1, LIGHT=0;
  const Piece = (color,isKing=false)=>({c:color,k:isKing});
  function cloneBoard(b){ return b.map(row=>row.map(p=> p? {c:p.c,k:p.k}:null)); }
  function inside(x,y){ return x>=0 && x<SIZE && y>=0 && y<SIZE; }
  const DIRS = [[1,1],[1,-1],[-1,1],[-1,-1]];

  const UI = {
    board:document.getElementById('board'),
    turn:document.getElementById('turnLabel'),
    status:document.getElementById('statusLabel'),
    start:document.getElementById('btn-newgame'),
    mustCap:document.getElementById('mustCapture'),
    level:document.getElementById('level'),
    mode:document.getElementById('mode'),
    yourColor:document.getElementById('yourColor'),
    sfxOn:document.getElementById('sfxOn'),
    undo:document.getElementById('btnUndo'), hint:document.getElementById('btnHint'), restart:document.getElementById('btnRestart'),
  };

  const State = {
    board:null, turn:LIGHT, history:[], mustCapture:true, mode:"ai", humanColor:LIGHT, aiDepth:1,
    lock:false, dragging:null, hover:null, selectable:[], movesCache:null, gameOver:false
  };

  /* =============== Стартовые позиции =============== */
  function startBoard(){
    const b = Array.from({length:SIZE},()=>Array(SIZE).fill(null));
    for(let y=0;y<3;y++){
      for(let x=0;x<SIZE;x++) if((x+y)%2===1) b[y][x]=Piece(DARK,false);
    }
    for(let y=SIZE-3;y<SIZE;y++){
      for(let x=0;x<SIZE;x++) if((x+y)%2===1) b[y][x]=Piece(LIGHT,false);
    }
    return b;
  }

  /* =============== Рендер =============== */
  const ctx = UI.board.getContext('2d');
  let cellPx = 1024/SIZE;
  let themeColors = {};

  function updateThemeColors(){
    const st = getComputedStyle(document.body);
    themeColors = {
      boardLight: st.getPropertyValue('--board-light').trim(),
      boardDark: st.getPropertyValue('--board-dark').trim(),
      pieceLight: st.getPropertyValue('--piece-light').trim(),
      pieceDark: st.getPropertyValue('--piece-dark').trim(),
    };
  }

  const savedSettings = JSON.parse(localStorage.getItem('settings')||'{}');
  UI.sfxOn.checked = savedSettings.sfx ?? true;
  updateThemeColors();

  function saveSettings(){
    localStorage.setItem('settings', JSON.stringify({
      sfx:UI.sfxOn.checked
    }));
  }

  UI.sfxOn.addEventListener('change', saveSettings);
  window.addEventListener('theme-change', ()=>{ updateThemeColors(); draw(); });

  function draw(){
    const b=State.board || Array.from({length:SIZE},()=>Array(SIZE).fill(null));
    ctx.clearRect(0,0,UI.board.width,UI.board.height);
    for(let y=0;y<SIZE;y++){
      for(let x=0;x<SIZE;x++){
        const dark=((x+y)&1)===1;
        ctx.fillStyle = dark? themeColors.boardDark : themeColors.boardLight;
        ctx.fillRect(x*cellPx,y*cellPx,cellPx,cellPx);
      }
    }
    if(State.selectable.length){
      ctx.fillStyle='rgba(80,180,255,.25)';
      for(const [x,y] of State.selectable) ctx.fillRect(x*cellPx,y*cellPx,cellPx,cellPx);
    }
    if(State.hover){ ctx.fillStyle='rgba(255,255,100,.22)'; const [x,y]=State.hover; ctx.fillRect(x*cellPx,y*cellPx,cellPx,cellPx); }
    if(State.dragging && State.dragging.targets){
      ctx.fillStyle='rgba(50,230,120,.25)';
      for(const t of State.dragging.targets){
        ctx.beginPath(); ctx.arc((t.x+.5)*cellPx,(t.y+.5)*cellPx, cellPx*0.22, 0, Math.PI*2); ctx.fill();
      }
    }
    for(let y=0;y<SIZE;y++){
      for(let x=0;x<SIZE;x++){
        const p=b[y][x]; if(!p) continue;
        if(State.dragging && State.dragging.x===x && State.dragging.y===y) continue;
        drawPiece(x,y,p);
      }
    }
    if(State.dragging){
      drawPiece(State.dragging.fx, State.dragging.fy, State.dragging.piece, true);
    }
  }
  function drawPiece(x,y,p,free=false){
    const cx=(x+.5)*cellPx, cy=(y+.5)*cellPx, r=cellPx*.36;
    ctx.save();
    if(free){ ctx.globalAlpha=.85; }
    const grad=ctx.createRadialGradient(cx-r*.3,cy-r*.3,r*.2,cx,cy,r);
    if(p.c===LIGHT){ grad.addColorStop(0,'#fff'); grad.addColorStop(1,themeColors.pieceLight); }
    else { grad.addColorStop(0,'#7a0000'); grad.addColorStop(1,themeColors.pieceDark); }
    ctx.fillStyle=grad; ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill();
    ctx.lineWidth=2; ctx.strokeStyle='rgba(0,0,0,.35)'; ctx.stroke();
    if(p.k){
      ctx.lineWidth=3; ctx.strokeStyle='rgba(255,215,120,.9)';
      ctx.beginPath(); ctx.arc(cx,cy,r*.55,0,Math.PI*2); ctx.stroke();
    }
    ctx.restore();
  }

  /* =============== Генератор ходов (русские шашки) =============== */
  function movesFor(b, x,y, mustCap){
    const p=b[y][x]; if(!p) return [];
    const color=p.c, enemy=1-color;
    const res=[];
    function push(path,captures){
      res.push({from:{x,y}, to:path[path.length-1], path, captures:[...captures], piece:p});
    }
    if(!mustCap){
      if(!p.k){
        const dir = (color===LIGHT? -1:1);
        for(const dx of [-1,1]){
          const nx=x+dx, ny=y+dir;
          if(inside(nx,ny) && !b[ny][nx]) push([{x:nx,y:ny}],[]);
        }
      }else{
        for(const [dx,dy] of DIRS){
          let nx=x+dx, ny=y+dy;
          while(inside(nx,ny) && !b[ny][nx]){ push([{x:nx,y:ny}],[]); nx+=dx; ny+=dy; }
        }
      }
    }
    function searchCap(cx,cy,board,caps,path,becameKing){
      let found=false;
      if(!p.k && !becameKing){
        for(const [dx,dy] of DIRS){
          const mx=cx+dx, my=cy+dy, lx=cx+2*dx, ly=cy+2*dy;
          if(!inside(lx,ly)||!inside(mx,my)) continue;
          if(board[my][mx] && board[my][mx].c===enemy && !board[ly][lx]){
            const nb=cloneBoard(board);
            nb[my][mx]=null; nb[cy][cx]=null; nb[ly][lx]=Piece(color,false);
            let became = becameKing || (color===LIGHT? ly===0 : ly===SIZE-1);
            if(became) nb[ly][lx].k=true;
            searchCap(lx,ly,nb,[...caps,{x:mx,y:my}],[...path,{x:lx,y:ly}],became);
            found=true;
          }
        }
      }else{
        for(const [dx,dy] of DIRS){
          let nx=cx+dx, ny=cy+dy; let met=null;
          while(inside(nx,ny)){
            if(!met && board[ny][nx]==null){ nx+=dx; ny+=dy; continue; }
            if(!met && board[ny][nx] && board[ny][nx].c===enemy){ met={x:nx,y:ny}; nx+=dx; ny+=dy; continue; }
            if(met && board[ny] && board[ny][nx]==null){
              const nb=cloneBoard(board);
              nb[met.y][met.x]=null; nb[cy][cx]=null; nb[ny][nx]=Piece(color,true);
              searchCap(nx,ny,nb,[...caps,{x:met.x,y:met.y}],[...path,{x:nx,y:ny}],true);
              found=true; nx+=dx; ny+=dy; continue;
            }
            break;
          }
        }
      }
      if(!found && caps.length){ push(path,caps); }
    }
    searchCap(x,y,b,[],[],false);
    if(res.some(m=>m.captures.length)) return res.filter(m=>m.captures.length>0);
    return res;
  }

  function allMoves(b, turn, mustCap){
    const ms=[];
    for(let y=0;y<SIZE;y++) for(let x=0;x<SIZE;x++){
      const p=b[y][x]; if(p && p.c===turn){ const list=movesFor(b,x,y,mustCap); for(const m of list) ms.push({...m, from:{x,y}}); }
    }
    if(mustCap){
      const max = ms.reduce((a,m)=>Math.max(a,m.captures.length),0);
      if(max>0) return ms.filter(m=>m.captures.length===max);
      return allMoves(b, turn, false);
    }
    return ms;
  }

  /* =============== Применение хода (ЕДИНАЯ ТОЧКА) =============== */
  function playMove(state, move, {silent=false}={}){
    if(!move) return state;
    const b=cloneBoard(state.board);
    const {from,to,captures}=move;
    const src=b[from.y][from.x];
    if(!src) return state;
    b[from.y][from.x]=null;
    const isPromotion = (!src.k && ((src.c===LIGHT && to.y===0) || (src.c===DARK && to.y===SIZE-1)));
    b[to.y][to.x]=Piece(src.c, src.k || isPromotion);
    for(const c of captures) b[c.y][c.x]=null;
    const next = {
      ...state,
      board:b,
      history:[...state.history, {move, board:state.board}],
    };
    if(!silent){
      if(window.AudioAPI && UI.sfxOn.checked) window.AudioAPI.playMove();
    }
    const must = state.mustCapture && captures.length>0;
    if(must){
      const cont = movesFor(b, to.x,to.y, true).filter(m=>m.captures.length>0);
      if(cont.length){
        next.turn = state.turn;
        State.selectable = [[to.x,to.y]];
        State.dragging=null; State.movesCache=cont;
        State.status = "Продолжайте серию";
        return next;
      }
    }
    next.turn = 1 - state.turn;
    State.selectable=[]; State.movesCache=null;
    const oppMoves = allMoves(b, next.turn, state.mustCapture);
    if(oppMoves.length===0){
      next.gameOver = true;
      State.status = (next.turn===LIGHT? "Белые":"Чёрные")+" без ходов. Победа!";
      if(window.AudioAPI){
        const result = (State.humanColor === next.turn)? 'lose':'win';
        window.AudioAPI.showEndModal({result, onNew:newGameFromMenu, onSettings:showSettings});
      }
    }else{
      State.status = "Идёт игра";
    }
    return next;
  }

  /* =============== ИИ (минимакс) =============== */
  function evaluate(b, me){
    let score=0;
    for(let y=0;y<SIZE;y++) for(let x=0;x<SIZE;x++){
      const p=b[y][x]; if(!p) continue;
      const w = (p.k? 3:1) + (p.c===LIGHT? (7-y)*.04 : y*.04);
      score += p.c===me ? w : -w;
    }
    return score;
  }
  function minimax(b, turn, depth, mustCap, me, alpha=-1e9, beta=1e9){
    if(depth===0){ return {score:evaluate(b, me)}; }
    const moves = allMoves(b, turn, mustCap);
    if(!moves.length) return {score: turn===me? -9999: 9999};
    let best=null;
    for(const m of moves){
      const s={board:b,history:[],turn, mustCapture:mustCap};
      const n = playMove(s, m, {silent:true});
      const r = minimax(n.board, n.turn, depth-1, mustCap, me, alpha, beta);
      const sc=r.score;
      if(turn===me){
        if(!best || sc>best.score){ best={score:sc, move:m}; alpha=Math.max(alpha,sc); }
        if(beta<=alpha) break;
      }else{
        if(!best || sc<best.score){ best={score:sc, move:m}; beta=Math.min(beta,sc); }
        if(beta<=alpha) break;
      }
    }
    return best;
  }

  /* =============== Взаимодействие (тап/drag) =============== */
  const boardEl = UI.board;
  function boardXY(evt){
    const r=boardEl.getBoundingClientRect();
    const clientX = evt.touches ? evt.touches[0].clientX : evt.clientX;
    const clientY = evt.touches ? evt.touches[0].clientY : evt.clientY;
    const x = Math.floor((clientX - r.left) / r.width * SIZE);
    const y = Math.floor((clientY - r.top) / r.height * SIZE);
    return [Math.max(0,Math.min(SIZE-1,x)), Math.max(0,Math.min(SIZE-1,y))];
  }
  function onPointerDown(e){
    if(State.lock||State.gameOver) return;
    const [x,y]=boardXY(e);
    const p=State.board[y][x]; if(!p) return;
    if(p.c!==State.turn) return;
    let moves;
    if(State.movesCache){
      moves = State.movesCache.filter(m=>m.from.x===x && m.from.y===y);
    }else{
      moves=allMoves(State.board, State.turn, State.mustCapture).filter(m=>m.from.x===x&&m.from.y===y);
      if(moves.some(m=>m.captures.length>0)){
        const max = moves.reduce((a,m)=>Math.max(a,m.captures.length),0);
        moves = moves.filter(m=>m.captures.length===max);
      }
    }
    if(!moves.length) return;
    if(State.movesCache && (x!==State.selectable[0][0] || y!==State.selectable[0][1])) return;
    State.dragging={x,y, piece:p, fx:x, fy:y, targets:moves.map(m=>m.to), moves};
    State.hover=[x,y];
    State.selectable=[[x,y]];
    draw();
  }
  function onPointerMove(e){
    if(State.dragging){
      const [x,y]=boardXY(e);
      State.dragging.fx=x; State.dragging.fy=y;
      draw();
    }else{
      const [x,y]=boardXY(e); State.hover=[x,y]; draw();
    }
  }
  function onPointerUp(e){
    if(!State.dragging) return;
    const [x,y]=boardXY(e);
    const cand = State.dragging.moves.find(m=>m.to.x===x && m.to.y===y);
    if(cand){
      Object.assign(State, playMove(State, cand));
      syncUI();
      if(State.mode==="ai" && State.turn!==State.humanColor && !State.gameOver){
        thinkAI();
      }
    }
    State.dragging=null; State.hover=null; draw();
  }
  ['pointerdown','mousedown','touchstart'].forEach(t=>boardEl.addEventListener(t,onPointerDown,{passive:false}));
  ['pointermove','mousemove','touchmove'].forEach(t=>boardEl.addEventListener(t,onPointerMove,{passive:false}));
  ['pointerup','mouseup','touchend','touchcancel'].forEach(t=>boardEl.addEventListener(t,onPointerUp,{passive:false}));

  /* =============== Игра/ИИ/Кнопки =============== */
  function syncUI(){
    UI.turn.textContent = (State.turn===LIGHT? "Белые":"Чёрные");
    UI.status.textContent = State.status || "Идёт игра";
    draw();
  }
  async function thinkAI(){
    State.lock=true; UI.status.textContent="ИИ думает…"; draw();
    await new Promise(r=>setTimeout(r, 120));
    const depth = State.aiDepth+1;
    const best = minimax(State.board, State.turn, depth, State.mustCapture, State.turn);
    Object.assign(State, playMove(State, best.move));
    State.lock=false; syncUI();
  }
  function newGameFromMenu(){
    State.board=startBoard(); State.turn=LIGHT; State.history=[]; State.gameOver=false; State.status="Идёт игра";
    State.mustCapture = UI.mustCap.checked;
    State.mode = UI.mode.value;
    State.humanColor = UI.yourColor.value==="white"? LIGHT: DARK;
    State.aiDepth = parseInt(UI.level.value,10);
    State.selectable=[]; State.movesCache=null; State.dragging=null; State.hover=null;
    if(State.mode==="ai" && State.humanColor!==State.turn){ setTimeout(thinkAI, 200); }
    showGame();
    syncUI();
  }

  UI.undo.addEventListener('click', ()=>{
    if(!State.history.length) return;
    const last=State.history.pop();
    State.board=last.board; State.turn=1-State.turn; State.gameOver=false; State.status="Ход отменён";
    State.selectable=[]; State.movesCache=null;
    draw(); syncUI();
  });
  UI.hint.addEventListener('click', ()=>{
    const moves=allMoves(State.board, State.turn, State.mustCapture);
    if(!moves.length) return;
    const best=minimax(State.board, State.turn, (State.aiDepth+1), State.mustCapture, State.turn);
    State.selectable=[[best.move.from.x,best.move.from.y]];
    State.dragging={x:best.move.from.x,y:best.move.from.y, fx:best.move.to.x, fy:best.move.to.y, piece:State.board[best.move.from.y][best.move.from.x], targets:[best.move.to], moves:[best.move]};
    State.status="Подсказка: выделен лучший ход";
    draw();
  });
  UI.restart.addEventListener('click', showSettings);
  UI.start.addEventListener('click', newGameFromMenu);

  (function boot(){ draw(); showSettings(); })();
</script>
<script src="./src/board-layout.js"></script>
</body>
</html>
